package sqlgen

import (
	"context"
	"database/sql"
	"testing"

	_ "github.com/go-sql-driver/mysql"
	_ "github.com/jackc/pgx/v5/stdlib"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/mysql"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

func TestGetTableNameWithRealSQL(t *testing.T) {
	testCases := []struct {
		name      string
		sql       string
		expected  string
		shouldErr bool
	}{
		{
			name:     "Simple INSERT",
			sql:      "INSERT INTO users (id, name) VALUES ($1, $2)",
			expected: "users",
		},
		{
			name:     "Simple SELECT",
			sql:      "SELECT id, name FROM customers WHERE active = true",
			expected: "customers",
		},
		{
			name:     "INSERT with schema",
			sql:      "INSERT INTO public.products (sku, price) VALUES ($1, $2)",
			expected: "public.products",
		},
		{
			name:     "Complex SELECT with JOIN",
			sql:      "SELECT u.name FROM users u JOIN orders o ON u.id = o.user_id",
			expected: "users",
		},
		{
			name:      "Invalid SQL",
			sql:       "NOT A VALID SQL STATEMENT",
			shouldErr: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			tableName, err := GetTableName(tc.sql)
			
			if tc.shouldErr {
				if err == nil {
					t.Errorf("expected error for SQL: %s", tc.sql)
				}
				return
			}
			
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			
			if tableName != tc.expected {
				t.Errorf("expected table name %q, got %q", tc.expected, tableName)
			}
		})
	}
}

func TestPostgresWithTestcontainers(t *testing.T) {
	ctx := context.Background()
	
	postgresContainer, err := postgres.Run(ctx,
		"postgres:16-alpine",
		postgres.WithDatabase("testdb"),
		postgres.WithUsername("postgres"),
		postgres.WithPassword("postgres"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2)),
	)
	if err != nil {
		t.Fatalf("failed to start container: %s", err)
	}
	defer func() {
		if err := postgresContainer.Terminate(ctx); err != nil {
			t.Fatalf("failed to terminate container: %s", err)
		}
	}()
	
	connectionString, err := postgresContainer.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		t.Fatalf("failed to get connection string: %s", err)
	}
	
	db, err := sql.Open("pgx", connectionString)
	if err != nil {
		t.Fatalf("failed to connect to database: %s", err)
	}
	defer db.Close()
	
	// Create a test table
	_, err = db.Exec(`
		CREATE TABLE test_users (
			id SERIAL PRIMARY KEY,
			username VARCHAR(50) NOT NULL,
			email VARCHAR(100)
		)
	`)
	if err != nil {
		t.Fatalf("failed to create table: %s", err)
	}
	
	// Test with actual database operations
	t.Run("TestTableNameExtraction", func(t *testing.T) {
		// These SQLs would be generated by the tool
		insertSQL := "INSERT INTO test_users (username, email) VALUES ($1, $2)"
		selectSQL := "SELECT id, username, email FROM test_users WHERE id = $1"
		
		tableName, err := GetTableName(insertSQL)
		if err != nil {
			t.Errorf("failed to get table name from INSERT: %v", err)
		}
		if tableName != "test_users" {
			t.Errorf("expected table name 'test_users', got %q", tableName)
		}
		
		tableName, err = GetTableName(selectSQL)
		if err != nil {
			t.Errorf("failed to get table name from SELECT: %v", err)
		}
		if tableName != "test_users" {
			t.Errorf("expected table name 'test_users', got %q", tableName)
		}
	})
}

func TestMySQLWithTestcontainers(t *testing.T) {
	ctx := context.Background()
	
	mysqlContainer, err := mysql.Run(ctx,
		"mysql:8",
		mysql.WithDatabase("testdb"),
		mysql.WithUsername("root"),
		mysql.WithPassword("password"),
	)
	if err != nil {
		t.Fatalf("failed to start container: %s", err)
	}
	defer func() {
		if err := mysqlContainer.Terminate(ctx); err != nil {
			t.Fatalf("failed to terminate container: %s", err)
		}
	}()
	
	connectionString, err := mysqlContainer.ConnectionString(ctx)
	if err != nil {
		t.Fatalf("failed to get connection string: %s", err)
	}
	
	db, err := sql.Open("mysql", connectionString)
	if err != nil {
		t.Fatalf("failed to connect to database: %s", err)
	}
	defer db.Close()
	
	// Create a test table
	_, err = db.Exec(`
		CREATE TABLE test_products (
			id INT AUTO_INCREMENT PRIMARY KEY,
			name VARCHAR(100) NOT NULL,
			price DECIMAL(10, 2)
		)
	`)
	if err != nil {
		t.Fatalf("failed to create table: %s", err)
	}
	
	// Test with actual database operations
	t.Run("TestTableNameExtraction", func(t *testing.T) {
		// These SQLs would be generated by the tool
		insertSQL := "INSERT INTO test_products (name, price) VALUES (?, ?)"
		selectSQL := "SELECT id, name, price FROM test_products WHERE id = ?"
		
		tableName, err := GetTableName(insertSQL)
		if err != nil {
			t.Errorf("failed to get table name from INSERT: %v", err)
		}
		if tableName != "test_products" {
			t.Errorf("expected table name 'test_products', got %q", tableName)
		}
		
		tableName, err = GetTableName(selectSQL)
		if err != nil {
			t.Errorf("failed to get table name from SELECT: %v", err)
		}
		if tableName != "test_products" {
			t.Errorf("expected table name 'test_products', got %q", tableName)
		}
	})
}

func TestSnakeToPascalWithVariousCases(t *testing.T) {
	testCases := []struct {
		input    string
		expected string
	}{
		{"user_profile", "UserProfile"},
		{"order_items", "OrderItems"},
		{"product", "Product"},
		{"user_activity_log", "UserActivityLog"},
		{"api_key", "ApiKey"},
		{"", ""},
		{"single", "Single"},
		{"UPPER_CASE", "UpperCase"},
	}
	
	for _, tc := range testCases {
		t.Run(tc.input, func(t *testing.T) {
			result := SnakeToPascal(tc.input)
			if result != tc.expected {
				t.Errorf("SnakeToPascal(%q) = %q; want %q", tc.input, result, tc.expected)
			}
		})
	}
}

func TestSingularizeWithVariousWords(t *testing.T) {
	testCases := []struct {
		input    string
		expected string
	}{
		{"users", "user"},
		{"posts", "post"},
		{"categories", "category"},
		{"companies", "company"},
		{"people", "person"},
		{"children", "child"},
		{"data", "datum"}, // inflection library converts data to datum
		{"", ""},
	}
	
	for _, tc := range testCases {
		t.Run(tc.input, func(t *testing.T) {
			result := Singularize(tc.input)
			if result != tc.expected {
				t.Errorf("Singularize(%q) = %q; want %q", tc.input, result, tc.expected)
			}
		})
	}
}